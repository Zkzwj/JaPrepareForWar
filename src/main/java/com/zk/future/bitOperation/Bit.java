package com.zk.future.bitOperation;

public class Bit {

    public static void main(String[] args) {
        yuOperation();

        huoOperation();

        yiHuoOperation();

        feiOperation();

        zuoYiOperation();

        youYiOperation();

        operation();
    }

    /**
     * int a值 转换成二进制就是：10000001
     * int b值 转换成二进制就是：10000000
     * @return &运算规则，只有两个都是1，结果才是1，二进制结果是：10000000——> 转换成十进制为：128
     */
    public static void yuOperation(){
        int a = 129;
        int b = 128;
        System.out.println("&运算："+(a&b));
    }

    /**
     * int a值 转换成二进制就是：10000001
     * int b值 转换成二进制就是：10000000
     * @return  |的运算规则为，两个只有一个1，二进制结果才是1，或的结果为：10000001 —> 转换成十进制为：129
     */
    public static void huoOperation(){
        int a = 129;
        int b = 128;
        System.out.println("|运算："+(a|b));
    }

    /**
     * int a值 15转换成二进制就是：1111，
     * int b值 2转换成为二进制就是：0010
     * 异或的运算规律 可得结果：1101—> 13
     */
    public static void yiHuoOperation(){
        int a = 15;
        int b = 2;
        System.out.println("a与b 异或的结果为："+(a^b));
    }

    /**
     * int a值 2转换成为二进制就是：0010
     * 非运算求整数的二进制反码，~0可获得与机器字长无关的串1
     */
    public static void feiOperation(){
        int a = 2;
        System.out.println("a 非的结果为："+(~a));
    }

    /**
     * <<:左移，规则为，最边最高位丢弃，右边补齐0
     * 如果移动的位数超过了该类型的最大位数，那么编译器或对移动的位数取模
     */
    public static void zuoYiOperation(){

        // << 把 << 左边的数据乘以2的移动次幂
        // 3*2^2 = 3*4 = 12
        System.out.println("左移："+(3 << 2));
        // 例如：3 << 2 (3为int型)
        // ①：把3转换为二进制数字 0000 0000 0000 0000 0000 0000 0000 0011
        // ②：把该数字最高位(左侧) 的两个零移出，其他的数字都朝左平移2位
        // ③：在低位(右侧)的两个空位补零，则得到的结果是：0000 0000 0000 0000 0000 0000 0000 1100
    }

    /**
     * >> 右移规则为：最高位是0  左边补齐0  最高位是1 左边补齐1
     * 右移规则：符号为不变，左边不上符号位
     */
    public static void youYiOperation(){
        int a = 2;
        int b = 3;
        System.out.println("右移："+(b >> a));
    }

    // todo
    /**
     * 计算出24的二进制：11000
     * 	原码：10000000 00000000 00000000 00011000
     * 	反码：11111111 11111111 11111111 11100111
     * 	补码：11111111 11111111 11111111 11101000
     *
     * 	11111111 11111111 11111111 11101000
     * 	1111111111 11111111 11111111 111010(00) 补码
     *
     * 	补码：1111111111 11111111 11111111 111010
     * 	反码：1111111111 11111111 11111111 111001
     * 	原码：1000000000 00000000 00000000 000110
     *
     * 	结果：-6
     */

    /**
     * >>>:无符号右移 无论最高位是0还是1，左边补齐0；
     */

    // -------------------------    符号为:最高位同时表示图号，0为正数，1为负数    -----------------------------


    public static void operation(){
        /*
            1、二进制转换为十进制

            二进制转换为10进制的规律为： 每位的值 * 2的（当前位-1次方）
            例如：
                00000001 = 0 * 2^7 + 0 * 2^6 + 0 * 2^5 + 0 * 2^4 + 0 * 2^3 + 0 * 2^2 + 0 * 2^1 + 1 * 2^0  = 1
                00000010 = 0 * 2^7 + 0 * 2^6 + 0 * 2^5 + 0 * 2^4 + 0 * 2^3 + 0 * 2^2 + 1 * 2^1 + 0 * 2^0  = 2

            2、二进制的符号位：
                最高位表示符号位，0表示正数  ， 1表示负数


            3、将二进制负数转换为十进制：先对该二进制数取反，然后加1，再转换为十进制，然后在前面加上负号
                例如： 10101011 最高位为1，所以为负数
                   第一步：取反： 01010100
                   第二步：加1 ： 01010101
                   第三步：转换为10进制：85
                   第四步：加上负号： -85
                   所以      10101011 转换为十进制为 -85

            4、将十进制负数转换为二进制：先得到该十进制负数的绝对值，然后转换为二进制，然后将该二进制取反，然后加1
                例如：-85
                第一步：得到绝对值 85
                第二步：转换为二进制：01010101
                第二步：取反：                10101010
                第三步：加1：                 10101011
                所以，-85转换为二进制为  10101011
         */

        /*
        ~ ‘非’ 运算符是将目标数的进制去反，即0变成1 ，1变成0
        2的二进制码为 00000010 ， 它取反为11111101 ，可见取反后结果为负数（二进制负数转换为十进制的步骤为：将二进制去反，然后+1）
         将 11111101 转换为10进制 ，第一步去反 得到 00000010 然后 加1 得到 00000011 ，得到的结果为3 ，然后在前面加上负号就可以了
         所以结果为-3
         */
        System.out.println(~2);

        /*
          ^ 异或 ，计算方式为：两个二进制数的位相同则为0 不同则为1
          23转换为二进制为：00010111
          12转换为二进制为：00001100
                    计算结果为：00011011  =  27
         */
        System.out.println(23 ^ 12);

        /*
         & 按位与 ，计算方式为：两个二进制数的位都为1则为1 ，否则为0
         1的二进制为 ：00000001
         2的二进制为 ：00000010
              结果为 :00000000 = 0
         */
        System.out.println(1&2);

        /*
          | 按位或 ，计算方式为：两个二进制位有一个为1就为1，否者为0
          5 的二进制为：00000101
          6 的二进制为：00000110
                  结果为：00000111 = 7
         */
        System.out.println( 5 | 6);


        /*
          >> 有符号右移位  ，符号左边表示要被移位的数，右边表示需要移的位数，结果为正数则在左边补0，否则补1
          3 的二进制为：00000010
                向右移动1位：00000001 = 1
         */
        System.out.println(3 >> 1);
    }
}
